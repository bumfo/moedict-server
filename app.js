// Generated by CoffeeScript 1.3.3
(function() {
	var Definition, Dict, Entry, Heteronym, app, sql;

	var _ = require('underscore'), 
		fs = require('fs'), 
		express = require('express'), 
		async = require('async'),
		Sequelize = require('sequelize');

	sql = new Sequelize('database', 'username', 'password', {
		dialect: 'sqlite',
		storage: './db.sqlite3',
		logging: false,
		define: {
			underscored: true,
			timestamps: false
		}
	});

	Definition = sql.define('definitions', {
		id: Sequelize.INTEGER,
		heteronym_id: Sequelize.INTEGER,
		type: Sequelize.STRING,
		def: Sequelize.STRING,
		example: Sequelize.STRING,
		synonyms: Sequelize.STRING,
		antonyms: Sequelize.STRING,
		quote: Sequelize.STRING,
		link: Sequelize.STRING,
		source: Sequelize.STRING
	});

	Dict = sql.define('dicts', {
		id: Sequelize.INTEGER,
		name: Sequelize.STRING,
		type: Sequelize.INTEGER
	});

	Entry = sql.define('entries', {
		id: Sequelize.INTEGER,
		title: Sequelize.STRING,
		radical: Sequelize.STRING,
		stroke_count: Sequelize.INTEGER,
		non_radical_stroke_count: Sequelize.INTEGER,
		dict_id: Sequelize.INTEGER
	});

	Heteronym = sql.define('heteronyms', {
		id: Sequelize.INTEGER,
		entry_id: Sequelize.INTEGER,
		bopomofo: Sequelize.STRING,
		bopomofo2: Sequelize.STRING,
		pinyin: Sequelize.STRING
	});

	Dict.hasMany(Entry, {
		foreignKey: 'dict_id'
	});

	Entry.hasMany(Heteronym, {
		foreignKey: 'entry_id'
	});

	Heteronym.hasMany(Definition, {
		foreignKey: 'heteronym_id'
	});

	app = express();

	app.get('/', function(req, res) {
		return res.set('Content-Type', 'text/html').send(fs.readFileSync("./index.html"));
	});

	app.get('/s/:q', function(req, res) {
		var q;

		if (req.params['q']) {
			q = req.params['q'];
			res.set('Content-Type', 'application/json');

			return Entry.findAll({
				where: "title like '" + q + "%'"
			}).then(getHeteronyms);

			function getHeteronyms(entries) {
				// res.send(JSON.stringify(entries));

				async.mapSeries(entries, function(entry, callback) {
					entry.getHeteronyms().then(function(heteronyms) {
						callback(null, heteronyms);
					});
				}, getEntriesHeteronyms);

				function getEntriesHeteronyms(err, entriesHeteronyms) {
					entriesHeteronyms.forEach(function(heteronyms, i) {
						entries[i] = entries[i].dataValues;
						entries[i].heteronyms = heteronyms;
					});
					// res.send(JSON.stringify(entries));

					async.mapSeries(entriesHeteronyms, function(heteronyms, getEntriesHeteronyms) {
						async.mapSeries(heteronyms, function(heteronym, callback) {
							heteronym.getDefinitions().then(function(definitions) {
								callback(null, definitions);
							});
						}, getEntriesHeteronyms);
					}, getEntriesHeteronymsDefinitions);

					function getEntriesHeteronymsDefinitions(err, entriesHeteronymsDefinitions) {
						entriesHeteronymsDefinitions.forEach(function(heteronymsDefinitions, i) {
							heteronymsDefinitions.forEach(function(definitions, j) {
								entries[i].heteronyms[j] = entries[i].heteronyms[j].dataValues;
								entries[i].heteronyms[j].definitions = definitions;
							});
						});

						// console.log(entriesHeteronymsDefinitions);

						res.send(JSON.stringify(entries));
					}
				}
			}
		}
	});

	app.listen('3000');

}).call(this);